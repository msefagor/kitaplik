<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Glass Planner Pro</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>

    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.12);
            --glass-border: rgba(255, 255, 255, 0.2);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            --primary-text: #ffffff;
            --accent-color: #00f2ff;
            --modal-bg: rgba(30, 30, 40, 0.95);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: var(--primary-text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        /* Arkaplan Efektleri */
        .blob {
            position: absolute; border-radius: 50%; filter: blur(90px); z-index: 0;
            animation: float 10s infinite ease-in-out;
        }
        .blob-1 { top: -10%; left: -20%; width: 350px; height: 350px; background: #8E2DE2; }
        .blob-2 { bottom: -10%; right: -20%; width: 400px; height: 400px; background: #4A00E0; animation-delay: 2s; }

        @keyframes float {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(20px, -20px); }
        }

        /* Ana Konteyner */
        .app-container {
            position: relative; z-index: 10; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom) 20px;
        }

        /* Glass Panel */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            border-radius: 28px;
            box-shadow: var(--glass-shadow);
            padding: 24px;
            margin-top: 10px;
            flex: 1;
            display: flex; flex-direction: column; overflow: hidden;
            position: relative;
        }

        /* Ekranlar Arası Geçiş */
        .screen {
            display: none; flex-direction: column; height: 100%;
            animation: fadeIn 0.4s ease-out;
        }
        .screen.active { display: flex; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        h1, h2 { margin: 0; font-weight: 700; }
        .date-display { font-size: 28px; letter-spacing: -0.5px; }

        /* Üst Bar */
        .top-bar {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 25px; padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        /* Butonlar */
        .btn-icon {
            background: rgba(255,255,255,0.1); border: none; color: white;
            width: 44px; height: 44px; border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; cursor: pointer; transition: 0.2s;
        }
        .btn-icon:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }

        .btn-add {
            background: var(--accent-color); color: #000;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.4);
        }

        .btn-main {
            background: linear-gradient(92deg, #00c6ff, #0072ff);
            border: none; border-radius: 16px; color: white;
            padding: 18px; font-size: 18px; font-weight: 600;
            width: 100%; margin-top: auto;
            box-shadow: 0 4px 20px rgba(0, 114, 255, 0.3);
        }

        /* Liste Alanı */
        .task-list {
            flex: 1; overflow-y: auto; padding-right: 5px;
        }
        .task-item {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.05);
            margin-bottom: 12px; padding: 16px;
            border-radius: 18px; display: flex; align-items: center;
            transition: 0.3s;
        }
        .task-item.completed { opacity: 0.5; }
        .task-item.completed .task-text { text-decoration: line-through; }

        .checkbox {
            width: 24px; height: 24px; border-radius: 6px; border: 2px solid var(--accent-color);
            margin-right: 15px; display: flex; align-items: center; justify-content: center;
            cursor: pointer;
        }
        .checkbox.checked { background: var(--accent-color); }
        .checkbox.checked::after { content: '✓'; color: black; font-weight: bold; font-size: 14px; }

        .task-content { flex: 1; }
        .task-text { font-size: 16px; font-weight: 500; }
        .task-meta { font-size: 12px; color: rgba(255,255,255,0.6); margin-top: 4px; display: flex; gap: 8px; align-items: center; }

        /* Inputlar */
        input[type="date"] {
            background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 15px; border-radius: 14px; width: 100%;
            font-size: 18px; margin: 20px 0; font-family: inherit;
        }

        /* MODAL (Not Ekleme) */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(5px);
            z-index: 100; display: none; justify-content: center; align-items: flex-end;
        }
        .modal-overlay.open { display: flex; animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1); }

        .modal-content {
            background: #1e1e24; width: 100%; border-radius: 30px 30px 0 0;
            padding: 25px; box-shadow: 0 -10px 40px rgba(0,0,0,0.5);
            border-top: 1px solid rgba(255,255,255,0.15);
        }

        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }

        .input-row { display: flex; gap: 10px; margin-bottom: 15px; }
        .modal-input {
            width: 100%; background: #2a2a35; border: none; color: white;
            padding: 16px; border-radius: 14px; font-size: 16px;
        }
        .time-input { flex: 0.4; background: #2a2a35; border: none; color: white; padding: 16px; border-radius: 14px; }

        /* HANDWRITING CANVAS */
        .canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200; display: none; flex-direction: column;
        }
        .canvas-container.open { display: flex; }
        canvas { background: white; width: 100%; flex: 1; touch-action: none; }
        .canvas-tools {
            padding: 12px 12px; background: #1a1a2e; display: flex; justify-content: space-between;
            align-items: center; border-bottom: 1px solid #333; gap: 10px;
        }

        .tool-group { display: flex; gap: 10px; align-items: center; }
        .tool-chip {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.12);
            color: white;
            border-radius: 14px;
            padding: 8px 10px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .tool-chip input[type="range"] { width: 110px; }

        .loader { border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* OCR preview (opsiyonel debug) */
        .ocr-preview {
            width: 86px; height: 52px; border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.06);
            object-fit: cover;
            display: none; /* istersen true yap */
        }
    </style>
</head>
<body>
<div class="blob blob-1"></div>
<div class="blob blob-2"></div>

<div class="app-container">
    <div class="glass-panel">

        <div id="screen-welcome" class="screen active">
            <div style="margin-top: 20px;">
                <h1 style="font-size: 32px;">Hoş Geldin.</h1>
                <p style="opacity: 0.7;">Planlamak istediğin günü seç.</p>
            </div>

            <div style="flex: 1; display: flex; flex-direction: column; justify-content: center;">
                <input type="date" id="datePicker">
            </div>

            <button class="btn-main" onclick="openSelectedDate()">
                Devam Et <i class="fas fa-chevron-right" style="margin-left: 10px;"></i>
            </button>
        </div>

        <div id="screen-tasks" class="screen">
            <div class="top-bar">
                <button class="btn-icon" onclick="goBack()"><i class="fas fa-arrow-left"></i></button>
                <div style="text-align: center;">
                    <span style="font-size: 12px; opacity: 0.7; display: block;">Seçili Tarih</span>
                    <span id="displayDate" style="font-size: 18px; font-weight: 600;">--</span>
                </div>
                <button class="btn-icon btn-add" onclick="openAddModal()"><i class="fas fa-plus"></i></button>
            </div>

            <div id="taskList" class="task-list">
                <div style="text-align: center; opacity: 0.5; margin-top: 50px;">
                    <i class="fas fa-clipboard-list" style="font-size: 40px; margin-bottom: 10px;"></i>
                    <p>Henüz not yok.<br>Sağ üstten ekleyebilirsin.</p>
                </div>
            </div>
        </div>

    </div>
</div>

<div id="addModal" class="modal-overlay" onclick="if(event.target === this) closeAddModal()">
    <div class="modal-content">
        <h3 style="margin: 0 0 15px 0;">Yeni Not Ekle</h3>

        <div class="input-row">
            <input type="text" id="modalTaskInput" class="modal-input" placeholder="Notunu yaz...">
            <button class="btn-icon" onclick="openCanvas()" style="background: #2a2a35; min-width: 50px;">
                <i class="fas fa-pen-nib"></i>
            </button>
            <button id="micBtn" class="btn-icon" onclick="toggleSpeech()" style="background: #2a2a35; min-width: 50px;">
                <i class="fas fa-microphone"></i>
            </button>
        </div>

        <div class="input-row">
            <div style="flex: 1; display: flex; align-items: center; background: #2a2a35; padding: 0 15px; border-radius: 14px; color: #aaa; font-size: 14px;">
                <i class="fas fa-bell" style="margin-right: 10px;"></i> Alarm:
            </div>
            <input type="time" id="modalTimeInput" class="time-input">
        </div>

        <button class="btn-main" onclick="saveTaskFromModal()" style="margin-top: 10px; border-radius: 14px; padding: 14px;">
            Kaydet
        </button>
    </div>
</div>

<!-- Canvas + OCR -->
<div id="canvasModal" class="canvas-container">
    <div class="canvas-tools">
        <button onclick="closeCanvas()" style="color: white; background: none; border: none; font-size: 16px;">İptal</button>

        <div class="tool-group">
            <button class="btn-icon" onclick="triggerBoardImage()" title="Tahta fotoğrafı yükle" style="background:#2a2a35; width:44px; height:44px;">
                <i class="fas fa-camera"></i>
            </button>
            <button class="btn-icon" onclick="rotateBoard(-90)" title="Sola çevir" style="background:#2a2a35; width:44px; height:44px;">
                <i class="fas fa-rotate-left"></i>
            </button>
            <button class="btn-icon" onclick="rotateBoard(90)" title="Sağa çevir" style="background:#2a2a35; width:44px; height:44px;">
                <i class="fas fa-rotate-right"></i>
            </button>

            <div class="tool-chip" title="Kalem kalınlığı">
                <i class="fas fa-pen"></i>
                <span id="penLabel">6</span>
                <input id="penSize" type="range" min="3" max="12" value="6" oninput="setPenSize(this.value)">
            </div>

            <img id="ocrPreview" class="ocr-preview" alt="OCR Preview">
        </div>

        <button onclick="clearCanvas()" style="color: #ff4757; background: none; border: none; font-size: 16px;">Temizle</button>
    </div>

    <canvas id="drawingCanvas"></canvas>

    <div style="padding: 18px; background: #1a1a2e; display: flex; justify-content: space-between; align-items: center; gap: 12px;">
        <span id="ocrHint" style="font-size: 12px; color: #888;">İpucu: Kalın ve ayrı harflerle yaz.</span>
        <button onclick="convertHandwriting()" class="btn-main" style="width: auto; padding: 10px 20px; margin: 0; display: flex; align-items: center; gap: 10px; border-radius: 14px;">
            <div id="ocrLoader" class="loader"></div>
            <span id="ocrBtnText">Metne Çevir & Ekle</span>
        </button>
    </div>
</div>

<!-- Fotoğraf seçici (gizli) -->
<input type="file" id="boardImageInput" accept="image/*" capture="environment" style="display:none">

<audio id="alarmSound" src="https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3"></audio>

<script>
    // --- Değişkenler ---
    let tasks = [];
    let selectedDate = '';
    let recognition;
    let isRecording = false;

    // Canvas Değişkenleri
    const canvas = document.getElementById('drawingCanvas');
    let ctx = null;

    // OCR / Board image
    const boardImageInput = document.getElementById('boardImageInput');
    let boardBaseCanvas = null;       // yüklenen fotoğrafın temel katmanı (optimize edilmiş)
    let boardRotation = 0;            // derece
    let penSize = 6;

    // Drawing state
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    // OCR Worker
    let ocrWorker = null;
    let ocrReady = false;
    let ocrInitInFlight = false;

    // --- Başlangıç ---
    window.onload = () => {
        // 1. Tarih Ayarı (Local Timezone Fix)
        const now = new Date();
        const offset = now.getTimezoneOffset() * 60000;
        const localISOTime = new Date(now.getTime() - offset).toISOString().split('T')[0];
        document.getElementById('datePicker').value = localISOTime;

        loadTasks();
        setupSpeech();
        setupCanvas();
        requestNotificationPermission();

        // Alarm döngüsü
        setInterval(checkAlarms, 10000);

        // OCR (lazy init yine de: arkaplanda hazırlansın)
        initOCR().catch(()=>{ /* sessiz */ });
    };

    // --- Navigasyon ---
    function openSelectedDate() {
        const dateInput = document.getElementById('datePicker').value;
        if(!dateInput) return;
        selectedDate = dateInput;

        const d = new Date(selectedDate);
        const options = { day: 'numeric', month: 'long', weekday: 'long' };
        document.getElementById('displayDate').innerText = d.toLocaleDateString('tr-TR', options);

        document.getElementById('screen-welcome').classList.remove('active');
        document.getElementById('screen-tasks').classList.add('active');
        renderTasks();
    }

    function goBack() {
        document.getElementById('screen-tasks').classList.remove('active');
        document.getElementById('screen-welcome').classList.add('active');
    }

    // --- Modal Yönetimi ---
    function openAddModal() {
        document.getElementById('modalTaskInput').value = '';
        document.getElementById('modalTimeInput').value = '';
        document.getElementById('addModal').classList.add('open');
        document.getElementById('modalTaskInput').focus();
    }

    function closeAddModal() {
        document.getElementById('addModal').classList.remove('open');
    }

    // --- Görev İşlemleri ---
    function saveTaskFromModal() {
        const text = document.getElementById('modalTaskInput').value.trim();
        const time = document.getElementById('modalTimeInput').value;

        if(!text) { alert('Lütfen not yazın.'); return; }

        const newTask = {
            id: Date.now(),
            date: selectedDate,
            text: text,
            time: time,
            completed: false,
            alarmTriggered: false
        };

        tasks.push(newTask);
        saveTasks();
        renderTasks();
        closeAddModal();
    }

    function toggleComplete(id) {
        const task = tasks.find(t => t.id === id);
        if(task) {
            task.completed = !task.completed;
            saveTasks();
            renderTasks();
        }
    }

    function deleteTask(e, id) {
        e.stopPropagation();
        if(confirm('Silmek istediğine emin misin?')) {
            tasks = tasks.filter(t => t.id !== id);
            saveTasks();
            renderTasks();
        }
    }

    function renderTasks() {
        const list = document.getElementById('taskList');
        const filteredTasks = tasks.filter(t => t.date === selectedDate);

        if(filteredTasks.length === 0) {
            list.innerHTML = `
                <div style="text-align: center; opacity: 0.5; margin-top: 50px;">
                    <i class="fas fa-clipboard-list" style="font-size: 40px; margin-bottom: 10px;"></i>
                    <p>Henüz not yok.<br>Sağ üstten ekleyebilirsin.</p>
                </div>`;
            return;
        }

        list.innerHTML = '';
        filteredTasks.forEach(task => {
            const div = document.createElement('div');
            div.className = `task-item ${task.completed ? 'completed' : ''}`;
            div.onclick = () => toggleComplete(task.id);

            const timeHtml = task.time ? `<span style="color:var(--accent-color)"><i class="far fa-clock"></i> ${task.time}</span>` : '';

            div.innerHTML = `
                <div class="checkbox ${task.completed ? 'checked' : ''}"></div>
                <div class="task-content">
                    <div class="task-text">${task.text}</div>
                    <div class="task-meta">${timeHtml}</div>
                </div>
                <button class="btn-icon" style="width:30px; height:30px; background:none; color:#ff4757;" onclick="deleteTask(event, ${task.id})">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            list.appendChild(div);
        });
    }

    // --- Veri Saklama ---
    function saveTasks() { localStorage.setItem('glassProTasks', JSON.stringify(tasks)); }
    function loadTasks() {
        const data = localStorage.getItem('glassProTasks');
        if(data) tasks = JSON.parse(data);
    }

    // =========================================================
    //  GELİŞMİŞ AKILLI TAHTA (CANVAS + OCR)
    // =========================================================

    function setupCanvas() {
        // context (performans için willReadFrequently)
        try {
            ctx = canvas.getContext('2d', { willReadFrequently: true });
        } catch (e) {
            ctx = canvas.getContext('2d');
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Pointer events (iOS dahil daha stabil)
        canvas.addEventListener('pointerdown', startDrawing, { passive: false });
        canvas.addEventListener('pointermove', draw, { passive: false });
        window.addEventListener('pointerup', stopDrawing, { passive: true });
        canvas.addEventListener('pointercancel', stopDrawing, { passive: true });

        // Fotoğraf yükleme
        boardImageInput.addEventListener('change', handleBoardImage);

        setPenSize(penSize);
    }

    function resizeCanvas() {
        const prev = document.createElement('canvas');
        prev.width = canvas.width || 1;
        prev.height = canvas.height || 1;
        const pctx = prev.getContext('2d');
        pctx.drawImage(canvas, 0, 0);

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 150;

        // Beyaz arkaplan
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Önce temel fotoğraf varsa tekrar çiz
        redrawBoardBase();

        // Eskiden çizilmiş katmanı ölçekli geri bas (basit yaklaşım)
        // Not: Tahta fotoğrafı varsa üst çizimler daha önemli; yoksa eski çizimi korur.
        try {
            ctx.drawImage(prev, 0, 0, prev.width, prev.height, 0, 0, canvas.width, canvas.height);
        } catch (e) {}
    }

    function setPenSize(v) {
        penSize = Number(v) || 6;
        const lbl = document.getElementById('penLabel');
        if (lbl) lbl.textContent = String(penSize);
    }

    function getCanvasPoint(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        return { x, y };
    }

    function startDrawing(e) {
        e.preventDefault();
        isDrawing = true;
        const p = getCanvasPoint(e);
        lastX = p.x; lastY = p.y;
    }

    function draw(e) {
        if (!isDrawing) return;
        e.preventDefault();

        const p = getCanvasPoint(e);

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(p.x, p.y);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = penSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();

        lastX = p.x; lastY = p.y;
    }

    function stopDrawing() { isDrawing = false; }

    function clearCanvas() {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        redrawBoardBase();
    }

    function openCanvas() {
        document.getElementById('canvasModal').classList.add('open');
        // açarken temizlemiyoruz: kullanıcı isterse fotoğraf+çizim kalsın
        if (!boardBaseCanvas) clearCanvas();
    }

    function closeCanvas() {
        document.getElementById('canvasModal').classList.remove('open');
    }

    // --- Tahta Fotoğrafı Yükleme ---
    function triggerBoardImage() {
        boardImageInput.value = '';
        boardImageInput.click();
    }

    async function handleBoardImage(e) {
        const file = e.target.files && e.target.files[0];
        if (!file) return;

        const img = new Image();
        img.onload = () => {
            // Fotoğrafı performans için optimize edilmiş bir base canvas'a al (max 2048)
            const maxDim = 2048;
            const scale = Math.min(1, maxDim / Math.max(img.width, img.height));
            const w = Math.max(1, Math.round(img.width * scale));
            const h = Math.max(1, Math.round(img.height * scale));

            boardBaseCanvas = document.createElement('canvas');
            boardBaseCanvas.width = w;
            boardBaseCanvas.height = h;
            const bctx = boardBaseCanvas.getContext('2d');
            bctx.fillStyle = '#fff';
            bctx.fillRect(0,0,w,h);
            bctx.drawImage(img, 0, 0, w, h);

            boardRotation = 0;
            clearCanvas(); // base'i de tekrar çizer
        };
        img.onerror = () => alert("Fotoğraf yüklenemedi.");
        img.src = URL.createObjectURL(file);
    }

    function rotateBoard(deg) {
        if (!boardBaseCanvas) return;
        boardRotation = (boardRotation + deg) % 360;
        clearCanvas();
    }

    function redrawBoardBase() {
        if (!boardBaseCanvas) return;

        const w = canvas.width, h = canvas.height;
        ctx.save();
        ctx.translate(w/2, h/2);
        ctx.rotate((boardRotation * Math.PI)/180);

        // fotoğrafı sığdır (contain)
        const bw = boardBaseCanvas.width;
        const bh = boardBaseCanvas.height;
        const s = Math.min(w / bw, h / bh);
        const dw = bw * s;
        const dh = bh * s;

        ctx.drawImage(boardBaseCanvas, -dw/2, -dh/2, dw, dh);
        ctx.restore();
    }

    // =========================================================
    //  OCR: Worker + Gelişmiş Ön-İşleme + Multi-Pass
    // =========================================================

    async function initOCR() {
        if (ocrReady) return;
        if (ocrInitInFlight) return;
        ocrInitInFlight = true;

        ocrWorker = await Tesseract.createWorker({
            logger: (m) => {
                // progress: m.progress (0..1)
                // istersen konsola bas:
                // console.log(m);
                const btnText = document.getElementById('ocrBtnText');
                if (btnText && m && m.status && typeof m.progress === 'number') {
                    const pct = Math.round(m.progress * 100);
                    btnText.innerText = `Okunuyor... (${pct}%)`;
                }
            }
        });

        // Türkçe + İngilizce (sayısal/harf karışık notlarda daha başarılı)
        await ocrWorker.loadLanguage('tur+eng');
        await ocrWorker.initialize('tur+eng');

        // Genel parametreler (multi-pass'te ayrıca set edilecek)
        await ocrWorker.setParameters({
            user_defined_dpi: '300',
            preserve_interword_spaces: '1'
        });

        ocrReady = true;
        ocrInitInFlight = false;
    }

    function getBestConfidence(data) {
        if (!data) return 0;
        if (Array.isArray(data.words) && data.words.length) {
            const good = data.words
                .filter(w => w && w.text && w.text.trim().length > 0 && typeof w.confidence === 'number' && w.confidence >= 0);
            if (!good.length) return typeof data.confidence === 'number' ? data.confidence : 0;
            const avg = good.reduce((s, w) => s + w.confidence, 0) / good.length;
            return avg;
        }
        return typeof data.confidence === 'number' ? data.confidence : 0;
    }

    function postProcessText(txt) {
        if (!txt) return '';
        let t = txt
            .replace(/[ \t]+\n/g, '\n')
            .replace(/\n{3,}/g, '\n\n')
            .replace(/[ \t]{2,}/g, ' ')
            .trim();

        // Çok basit düzeltmeler (isteğe göre artırılabilir)
        t = t.replace(/ﬁ/g, 'fi').replace(/’/g, "'");

        return t;
    }

    function createCanvas(w, h) {
        const c = document.createElement('canvas');
        c.width = Math.max(1, w);
        c.height = Math.max(1, h);
        return c;
    }

    function cropToContent(srcCanvas, pad = 18) {
        const w = srcCanvas.width, h = srcCanvas.height;
        const sctx = srcCanvas.getContext('2d', { willReadFrequently: true }) || srcCanvas.getContext('2d');
        const img = sctx.getImageData(0, 0, w, h);
        const d = img.data;

        let minX = w, minY = h, maxX = 0, maxY = 0;
        let found = false;

        // hız: 2 piksel adım
        for (let y = 0; y < h; y += 2) {
            for (let x = 0; x < w; x += 2) {
                const i = (y * w + x) * 4;
                const r = d[i], g = d[i+1], b = d[i+2];
                // beyaz değilse "içerik"
                if (r < 245 || g < 245 || b < 245) {
                    found = true;
                    if (x < minX) minX = x;
                    if (y < minY) minY = y;
                    if (x > maxX) maxX = x;
                    if (y > maxY) maxY = y;
                }
            }
        }

        if (!found) return srcCanvas;

        minX = Math.max(0, minX - pad);
        minY = Math.max(0, minY - pad);
        maxX = Math.min(w - 1, maxX + pad);
        maxY = Math.min(h - 1, maxY + pad);

        const cw = Math.max(1, maxX - minX + 1);
        const ch = Math.max(1, maxY - minY + 1);

        const out = createCanvas(cw, ch);
        const octx = out.getContext('2d');
        octx.fillStyle = '#fff';
        octx.fillRect(0, 0, cw, ch);
        octx.drawImage(srcCanvas, minX, minY, cw, ch, 0, 0, cw, ch);
        return out;
    }

    function scaleUp(srcCanvas, maxDim = 2200, preferScale = 3) {
        const w = srcCanvas.width, h = srcCanvas.height;
        const s = Math.min(preferScale, maxDim / Math.max(w, h));
        const nw = Math.max(1, Math.round(w * s));
        const nh = Math.max(1, Math.round(h * s));

        if (nw === w && nh === h) return srcCanvas;

        const out = createCanvas(nw, nh);
        const octx = out.getContext('2d');
        octx.imageSmoothingEnabled = true;
        octx.fillStyle = '#fff';
        octx.fillRect(0, 0, nw, nh);
        octx.drawImage(srcCanvas, 0, 0, w, h, 0, 0, nw, nh);
        return out;
    }

    function toGrayscaleAndContrast(srcCanvas, contrast = 1.8) {
        const out = createCanvas(srcCanvas.width, srcCanvas.height);
        const octx = out.getContext('2d');
        octx.fillStyle = '#fff';
        octx.fillRect(0, 0, out.width, out.height);

        // Canvas filter: hızlı kontrast
        octx.filter = `grayscale(1) contrast(${contrast})`;
        octx.drawImage(srcCanvas, 0, 0);
        octx.filter = 'none';
        return out;
    }

    function otsuThreshold(gray) {
        const hist = new Array(256).fill(0);
        for (let i = 0; i < gray.length; i++) hist[gray[i]]++;

        const total = gray.length;
        let sum = 0;
        for (let t = 0; t < 256; t++) sum += t * hist[t];

        let sumB = 0;
        let wB = 0;
        let wF = 0;
        let varMax = 0;
        let threshold = 128;

        for (let t = 0; t < 256; t++) {
            wB += hist[t];
            if (wB === 0) continue;

            wF = total - wB;
            if (wF === 0) break;

            sumB += t * hist[t];
            const mB = sumB / wB;
            const mF = (sum - sumB) / wF;

            const varBetween = wB * wF * (mB - mF) * (mB - mF);
            if (varBetween > varMax) {
                varMax = varBetween;
                threshold = t;
            }
        }
        return threshold;
    }

    function binarizeOtsu(srcCanvas) {
        const out = createCanvas(srcCanvas.width, srcCanvas.height);
        const octx = out.getContext('2d');
        octx.drawImage(srcCanvas, 0, 0);

        const img = octx.getImageData(0, 0, out.width, out.height);
        const d = img.data;

        const gray = new Uint8ClampedArray(out.width * out.height);
        for (let i = 0, p = 0; i < d.length; i += 4, p++) {
            // zaten grayscale ama güvenli
            const g = (d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114) | 0;
            gray[p] = g;
        }

        const th = otsuThreshold(gray);

        for (let i = 0, p = 0; i < d.length; i += 4, p++) {
            const v = gray[p] < th ? 0 : 255;
            d[i] = d[i+1] = d[i+2] = v;
            d[i+3] = 255;
        }
        octx.putImageData(img, 0, 0);
        return out;
    }

    function binarizeAdaptive(srcCanvas, win = 21, c = 10) {
        const out = createCanvas(srcCanvas.width, srcCanvas.height);
        const octx = out.getContext('2d');
        octx.drawImage(srcCanvas, 0, 0);

        const w = out.width, h = out.height;
        const img = octx.getImageData(0, 0, w, h);
        const d = img.data;

        const gray = new Uint8ClampedArray(w * h);
        for (let i = 0, p = 0; i < d.length; i += 4, p++) {
            const g = (d[i] * 0.299 + d[i+1] * 0.587 + d[i+2] * 0.114) | 0;
            gray[p] = g;
        }

        // integral image
        const integral = new Uint32Array((w + 1) * (h + 1));
        for (let y = 1; y <= h; y++) {
            let rowSum = 0;
            for (let x = 1; x <= w; x++) {
                rowSum += gray[(y - 1) * w + (x - 1)];
                integral[y * (w + 1) + x] = integral[(y - 1) * (w + 1) + x] + rowSum;
            }
        }

        const r = (win / 2) | 0;
        for (let y = 0; y < h; y++) {
            const y0 = Math.max(0, y - r);
            const y1 = Math.min(h - 1, y + r);
            for (let x = 0; x < w; x++) {
                const x0 = Math.max(0, x - r);
                const x1 = Math.min(w - 1, x + r);

                const A = integral[y0 * (w + 1) + x0];
                const B = integral[y0 * (w + 1) + (x1 + 1)];
                const Cc = integral[(y1 + 1) * (w + 1) + x0];
                const Dd = integral[(y1 + 1) * (w + 1) + (x1 + 1)];

                const area = (x1 - x0 + 1) * (y1 - y0 + 1);
                const mean = (Dd - B - Cc + A) / area;

                const g = gray[y * w + x];
                const v = (g < (mean - c)) ? 0 : 255;

                const idx = (y * w + x) * 4;
                d[idx] = d[idx+1] = d[idx+2] = v;
                d[idx+3] = 255;
            }
        }

        octx.putImageData(img, 0, 0);
        return out;
    }

    function dilateBlack(srcCanvas, iterations = 1) {
        const w = srcCanvas.width, h = srcCanvas.height;
        const out = createCanvas(w, h);
        const sctx = srcCanvas.getContext('2d', { willReadFrequently: true }) || srcCanvas.getContext('2d');
        const octx = out.getContext('2d', { willReadFrequently: true }) || out.getContext('2d');

        let img = sctx.getImageData(0, 0, w, h);

        for (let it = 0; it < iterations; it++) {
            const src = img.data;
            const next = new ImageData(w, h);
            const dst = next.data;

            // beyazla başla
            for (let i = 0; i < dst.length; i += 4) {
                dst[i] = dst[i+1] = dst[i+2] = 255;
                dst[i+3] = 255;
            }

            for (let y = 1; y < h - 1; y++) {
                for (let x = 1; x < w - 1; x++) {
                    let black = false;
                    for (let ky = -1; ky <= 1 && !black; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const ii = ((y + ky) * w + (x + kx)) * 4;
                            if (src[ii] === 0) { black = true; break; }
                        }
                    }
                    const idx = (y * w + x) * 4;
                    if (black) dst[idx] = dst[idx+1] = dst[idx+2] = 0;
                }
            }

            img = next;
        }

        octx.putImageData(img, 0, 0);
        return out;
    }

    async function runMultiPassOCR(preppedCanvas) {
        // farklı PSM'ler: 6 (blok), 4 (tek sütun), 11 (sparse)
        const paramSets = [
            { tessedit_pageseg_mode: 6, preserve_interword_spaces: '1' },
            { tessedit_pageseg_mode: 4, preserve_interword_spaces: '1' },
            { tessedit_pageseg_mode: 11, preserve_interword_spaces: '1' },
            // whitelist denemesi (bazı el yazılarında çok iyi sonuç verir)
            {
                tessedit_pageseg_mode: 6,
                preserve_interword_spaces: '1',
                tessedit_char_whitelist: " ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZabcçdefgğhıijklmnoöprsştuüvyz0123456789.,:;!?-()/%+*=’'\""
            }
        ];

        let best = { text: '', conf: -1 };

        for (const params of paramSets) {
            await ocrWorker.setParameters(params);
            const res = await ocrWorker.recognize(preppedCanvas);
            const txt = postProcessText(res?.data?.text || '');
            const conf = getBestConfidence(res?.data);

            // boş metni ele
            if (txt && txt.length > 0 && conf > best.conf) {
                best = { text: txt, conf };
            }
        }

        return best;
    }

    function updateOcrUI(isBusy, msg) {
        const btnText = document.getElementById('ocrBtnText');
        const loader = document.getElementById('ocrLoader');
        if (isBusy) {
            loader.style.display = 'block';
            btnText.innerText = msg || 'Okunuyor...';
        } else {
            loader.style.display = 'none';
            btnText.innerText = 'Metne Çevir & Ekle';
        }
    }

    async function convertHandwriting() {
        try {
            updateOcrUI(true, 'Hazırlanıyor...');
            await initOCR();

            // Kaynak: ekrandaki canvas (fotoğraf + çizim dahil)
            // OCR için: auto-crop + scale-up
            const cropped = cropToContent(canvas, 22);
            const scaled = scaleUp(cropped, 2200, 3);

            // Çoklu ön-işleme varyantları
            updateOcrUI(true, 'Görüntü iyileştiriliyor...');
            const v0 = toGrayscaleAndContrast(scaled, 2.0);
            const v1 = binarizeOtsu(v0);
            const v1b = dilateBlack(v1, 1);          // yazıyı kalınlaştır
            const v2 = binarizeAdaptive(v0, 21, 10);  // ışık değişimlerine daha dayanıklı
            const v2b = dilateBlack(v2, 1);

            // İstersen debug preview aç
            const preview = document.getElementById('ocrPreview');
            if (preview && preview.style.display !== 'none') {
                preview.src = v1b.toDataURL('image/jpeg', 0.85);
            }

            // OCR çoklu deneme: her varyantta multi-pass + en iyi confidence seç
            updateOcrUI(true, 'OCR taraması...');
            const candidates = [];
            candidates.push(await runMultiPassOCR(v1b));
            candidates.push(await runMultiPassOCR(v2b));
            candidates.push(await runMultiPassOCR(v1));
            candidates.push(await runMultiPassOCR(v2));

            // En iyi sonucu seç
            let best = { text: '', conf: -1 };
            for (const c of candidates) {
                if (c && c.text && c.text.trim().length > 0 && c.conf > best.conf) best = c;
            }

            const cleanText = (best.text || '').trim();

            if (cleanText) {
                const input = document.getElementById('modalTaskInput');
                input.value += (input.value ? ' ' : '') + cleanText;
                closeCanvas();
            } else {
                alert("Yazı okunamadı. İpucu: Kalemi kalınlaştır, satır aralarını aç, harfleri ayrı yaz.");
            }

        } catch (error) {
            console.error(error);
            alert("OCR sırasında bir hata oluştu.");
        } finally {
            updateOcrUI(false);
        }
    }

    // --- Sesli Komut ---
    function setupSpeech() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'tr-TR';
            recognition.continuous = false;

            recognition.onresult = (e) => {
                const txt = e.results[0][0].transcript;
                document.getElementById('modalTaskInput').value = txt;
                document.getElementById('micBtn').style.color = 'white';
                isRecording = false;
            };

            recognition.onend = () => { isRecording = false; document.getElementById('micBtn').style.color = 'white'; };
        }
    }

    function toggleSpeech() {
        if(!recognition) return alert('Tarayıcı desteklemiyor');
        if(isRecording) { recognition.stop(); }
        else {
            recognition.start();
            isRecording = true;
            document.getElementById('micBtn').style.color = '#ff4757';
        }
    }

    // --- Alarm ---
    function requestNotificationPermission() {
        if ("Notification" in window) Notification.requestPermission();
    }

    function checkAlarms() {
        const now = new Date();
        const currentTime = now.toTimeString().substring(0, 5);
        const todayStr = new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString().split('T')[0];

        tasks.forEach(task => {
            if (task.date === todayStr && task.time === currentTime && !task.alarmTriggered && !task.completed) {
                playAlarm(task.text);
                task.alarmTriggered = true;
                saveTasks();
            }
        });
    }

    function playAlarm(text) {
        document.getElementById('alarmSound').play().catch(e => console.log("Ses oynatılamadı, etkileşim lazım."));
        if (Notification.permission === "granted") {
            new Notification("⏰ Hatırlatıcı", { body: text });
        } else {
            alert("ALARM: " + text);
        }
    }
</script>
</body>
</html>
